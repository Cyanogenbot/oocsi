{"name":"Oocsi","tagline":"OOCSI â€“ a simple systems-interaction fabric for designers","body":"# oocsi\r\n\r\nThe OOCSI mission is to create a simple systems-interaction fabric for use by designers.\r\n\r\nThere are two basic components that form an OOCSI network: the client and the server. While the server can be started from the command line (see here), the client interface need to be embedded in other code and allows this code to access the OOCSI network, to send and receive data in a simple way.\r\n\r\n## Server\r\n\r\nThe server comes as a pre-compiled .jar file: [OOCSI_server.jar](server/dist/OOCSI_server.jar) (220kB)\r\n\r\nIt can be run simply by double-clicking on the JAR file in most operating systems. There are, however, command line parameters that are explained in the following:   \r\n\r\nSwitch on logging to a file with:\r\n\r\n\tOOCSI_server.jar -logging\r\n\r\nAllow for a certain maximum number of clients to be connected (here, 40):\r\n\r\n\tOOCSI_server.jar -clients 55\r\n\r\nRun the server on a specific port (instead of 4444 which is the default):\r\n\r\n\tOOCSI_server.jar -port 4545\r\n\r\nOf course, all parameters can be used at the same time, like this:\r\n\r\n\tOOCSI_server.jar -logging -clients 55 -port 4545 \r\n\r\n\r\n## Client\r\n\r\nOOCSI is a in essence a client-server message-bus infrastructure. With the server running, a client can connect an exchange\r\nmessages with other clients via the server. While there is a dedicated [Processing plug-in for OOCSI] (https://github.com/iddi/oocsi-processing), \r\na client interface for direct use in Java or JVM program is provided as well (see below). \r\n\r\n\r\n### Embedding the client\r\n\r\nThe Java OOCSI client can be embedded in any kind of Java program (or anything running on a JVM). The only dependency is the \r\n[oocsi.jar](https://github.com/iddi/oocsi-processing/blob/master/dist/oocsi/library/oocsi.jar) (20kB) library. Put this library\r\ninto the classpath and follow the steps below. \r\n\r\n### Connecting to the OOCSI network\r\n\r\nAs the first step, create an OOCSI client by providing a unique name to the OOCSIClient constructor:\r\n\r\n\tOOCSIClient sender = new OOCSIClient(\"sender\");\r\n\t\r\nConnect to a running OOCSI server on the same machine and the default port 4444.\r\n\t\r\n\tsender.connect(\"localhost\", 4444);\r\n\r\nConnect to a running OOCSI server on a different machine and a custom port 4545.\r\n\t\r\n\tsender.connect(\"123.123.123.123\", 4545);\r\n\r\n\r\n### Sending messages\r\n\r\nUse the OOCSIMessage class to create and send messages on the OOCSI network:  \r\n\r\n\tnew OOCSIMessage(sender, \"mychannel\").data(\"mykey\", \"myvalue\").send();\r\n\t\r\nIn this example a message is created to be sent with the OOCSIClient \"sender\" and destined for the channel \"mychannel\".\r\nA key-value pair of data (\"mykey\" : \"myvalue\") is added to the message by calling the data() method\r\nand finally, the message is sent to the OOCSI network.\r\n\r\n\r\n### Receiving messages and handling events\r\n\r\nFor receiving messages, another OOCSI client is initialized and started: \r\n\r\n\tOOCSIClient recipient = new OOCSIClient(\"myrecipient\");\r\n\trecipient.connect(\"localhost\", 4444);\r\n\t\r\nAgain, take care that the handle is unique and that the client connects to the right server.\r\n\r\nThis new client, recipient, subscribes for the channel \"mychannel\" and provides an EventHandler instance. This newly \r\ninstantiated object asynchronously receives all events sent on the respective channel and will call the internal\r\nmethod \"receive\". In this example, the event's timestamp will be printed in the console output.\r\n\r\n\trecipient.subscribe(\"mychannel\", new EventHandler() {\r\n\t\tpublic void receive(OOCSIEvent event) {\r\n\t\t\tSystem.out.println(event.getTimestamp());\r\n\t\t}\r\n\t});\r\n\r\n\r\n### Getting data from events\r\n\r\nAn OOCSIEvent has built-in infrastructure-level data fields such as _sender_, _timestamp_, and _channel_. In addition, the _recipient_ field is provided for some client implementations.\r\nEach of these fields can be access with a dedicated getter method:\r\n\r\n\tOOCSIEvent event = ...\r\n\t\r\n\t// sender and receiver\r\n\tString sender = event.getSender();\r\n\tString channel = event.getChannel();\r\n\tString channel = event.getRecipient();\r\n\t\r\n\t// time\r\n\tDate timestamp = event.getTimestamp();\r\n\tlong unixTime = event.getTime();\r\n\t\r\nApart from that, OOCSIEvents have a data payload that is freely definable and realized as a key-value store (Map<String, Object>). Such key-value pairs can be accessed with helper mthods\r\nthat will convert the data type of hte value accordingly: \r\n\t \r\n\tOOCSIEvent event = ...\r\n\tString stringValue = event.getString(\"mykey\");\r\n\tObject objectValue = event.getObject(\"mykey\");\r\n\t\r\nEvents do not guarantee that specific keys and values are contained. For these cases, default values can be used in the retrieval of event data. These default values (with the correct data type) are \r\nadded to the retrieval call as a second parameter, and they will be assigned if (1) the key could not be found, or (2) if the value could not converted to the specified data type.  \t\r\n\r\n\t// retrieval with an additional default value\r\n\tOOCSIEvent event = ...\r\n\tString stringValue = event.getString(\"mykey\", \"default\");\r\n\tlong longValue = event.getLong(\"mykey\", 0);\r\n\tint intValue = event.getInt(\"mykey\", 0);\r\n\tboolean booleanValue = event.getInt(\"mykey\", false);\r\n\r\nAs an alternative to using default values, one can also check whether the key is contained in the event:\r\n\r\n\tOOCSIEvent event = ...\r\n\tif(event.has(\"mykey\")) {\r\n\t\t// retrieve value\r\n\t}\r\n\t\r\nFinally, events can provide a list of contained keys, which can be used to dump all contained data or to systematically retrieve all data.\r\n\r\n\tOOCSIEvent event = ...\r\n\tString[] keys = event.keys();\r\n\t\r\n\r\n\r\n\r\n### Full example\r\n\r\nThe full example given below registers two clients, of which one subscribes for message on the channel \"mychannel\" and the\r\nother will send a single message on this channel. The subscribing client receives the message and prints out the value\r\nassociated with the key \"mykey\" and the timestamp of the event on the console.\r\n\r\n\r\n\tOOCSIClient recipient = new OOCSIClient(\"myrecipient\");\r\n\trecipient.connect(\"localhost\", 4444);\r\n\trecipient.subscribe(\"mychannel\", new EventHandler() {\r\n\t\tpublic void receive(OOCSIEvent event) {\r\n\t\t\tSystem.out.println(event.getString(\"mykey\") + \" >> \" + event.getTimestamp());\r\n\t\t}\r\n\t});\r\n\r\n\tOOCSIClient sender = new OOCSIClient(\"sender\");\r\n\tsender.connect(\"localhost\", 4444);\r\n\tnew OOCSIMessage(sender, \"mychannel\").data(\"mykey\", \"myvalue\").send();\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}